<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ê∂àÊ∂à‰πê</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #ecf0f1;
    }
    h1 {
      font-size: 48px;
      background: linear-gradient(135deg, #e74c3c, #f1c40f, #2ecc71, #3498db, #9b59b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 20px;
    }
    .header {
      display: flex;
      gap: 30px;
      margin-bottom: 20px;
      background: rgba(0,0,0,0.3);
      padding: 15px 30px;
      border-radius: 12px;
    }
    .stat { text-align: center; }
    .stat-label { font-size: 12px; color: #95a5a6; }
    .stat-value { font-size: 24px; font-weight: bold; }
    .stat-value.warning { color: #e74c3c; }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 4px;
      background: rgba(0,0,0,0.4);
      padding: 10px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .cell {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    .cell:hover { transform: scale(1.05); }
    .cell.selected {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px #fff, 0 0 0 5px #3498db;
    }
    .cell.removing {
      animation: pop 0.2s ease-out forwards;
    }
    .cell.falling {
      animation: drop 0.3s ease-in;
    }
    @keyframes pop {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); }
      100% { transform: scale(0); opacity: 0; }
    }
    @keyframes drop {
      0% { transform: translateY(-60px); }
      100% { transform: translateY(0); }
    }
    .controls {
      margin-top: 20px;
      display: flex;
      gap: 15px;
    }
    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s;
      background: linear-gradient(145deg, #34495e, #2c3e50);
      color: #ecf0f1;
    }
    .btn:hover { transform: translateY(-2px); }
    .btn.primary {
      background: linear-gradient(135deg, #3498db, #2980b9);
    }
    .combo {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #f39c12, #e74c3c);
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: bold;
      animation: bounce 0.3s;
      display: none;
    }
    .combo.show { display: block; }
    @keyframes bounce {
      0% { transform: scale(0.5); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: linear-gradient(145deg, #2c3e50, #1a252f);
      padding: 40px;
      border-radius: 16px;
      text-align: center;
    }
    .modal h2 { font-size: 32px; margin-bottom: 20px; }
    .stars { font-size: 40px; margin-bottom: 20px; }
    .star { color: #34495e; }
    .star.active { color: #f1c40f; }
    .final-score { font-size: 48px; color: #3498db; margin-bottom: 30px; }
  </style>
</head>
<body>
  <h1>Ê∂àÊ∂à‰πê</h1>
  <div class="header">
    <div class="stat">
      <div class="stat-label">ÂÖ≥Âç°</div>
      <div class="stat-value" id="level">1</div>
    </div>
    <div class="stat">
      <div class="stat-label">ÂàÜÊï∞</div>
      <div class="stat-value" id="score">0</div>
    </div>
    <div class="stat">
      <div class="stat-label">ÁõÆÊ†á</div>
      <div class="stat-value" id="target">1000</div>
    </div>
    <div class="stat">
      <div class="stat-label">Ê≠•Êï∞</div>
      <div class="stat-value" id="moves">20</div>
    </div>
  </div>
  <div id="board"></div>
  <div class="controls">
    <button class="btn" onclick="restartGame()">ÈáçÊñ∞ÂºÄÂßã</button>
    <button class="btn primary" onclick="nextLevel()">‰∏ã‰∏ÄÂÖ≥</button>
  </div>
  <div class="combo" id="combo">ËøûÂáª!</div>
  <div class="modal" id="modal">
    <div class="modal-content">
      <h2 id="modal-title">ÊÅ≠ÂñúÈÄöÂÖ≥!</h2>
      <div class="stars" id="stars">
        <span class="star">‚òÖ</span>
        <span class="star">‚òÖ</span>
        <span class="star">‚òÖ</span>
      </div>
      <div class="final-score" id="final-score">0</div>
      <div class="controls">
        <button class="btn" onclick="restartGame()">ÈáçÊñ∞ÂºÄÂßã</button>
        <button class="btn primary" onclick="nextLevel()">‰∏ã‰∏ÄÂÖ≥</button>
      </div>
    </div>
  </div>

  <script>
    const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22'];
    const SPECIALS = { NONE: 0, STRIPE_H: 1, STRIPE_V: 2, BOMB: 3, RAINBOW: 4 };
    const SIZE = 8;
    const LEVELS = [
      { moves: 20, target: 1000, colors: 4 },
      { moves: 18, target: 2000, colors: 5 },
      { moves: 15, target: 3000, colors: 5 },
      { moves: 15, target: 4000, colors: 6 },
      { moves: 12, target: 5000, colors: 6 }
    ];

    let board = [];
    let selected = null;
    let score = 0;
    let moves = 20;
    let level = 0;
    let combo = 0;
    let animating = false;

    function init() {
      const config = LEVELS[level];
      moves = config.moves;
      score = 0;
      combo = 0;
      selected = null;
      animating = false;
      document.getElementById('modal').classList.remove('show');
      generateBoard();
      render();
      updateUI();
    }

    function generateBoard() {
      const numColors = LEVELS[level].colors;
      board = [];
      for (let r = 0; r < SIZE; r++) {
        board[r] = [];
        for (let c = 0; c < SIZE; c++) {
          let color;
          do {
            color = Math.floor(Math.random() * numColors);
          } while (wouldMatch(r, c, color));
          board[r][c] = { color, special: SPECIALS.NONE };
        }
      }
    }

    function wouldMatch(r, c, color) {
      if (c >= 2 && board[r][c-1]?.color === color && board[r][c-2]?.color === color) return true;
      if (r >= 2 && board[r-1]?.[c]?.color === color && board[r-2]?.[c]?.color === color) return true;
      return false;
    }

    function render() {
      const container = document.getElementById('board');
      container.innerHTML = '';
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (board[r][c]) {
            cell.style.background = COLORS[board[r][c].color];
            if (board[r][c].special === SPECIALS.STRIPE_H) cell.textContent = '‚îÅ';
            else if (board[r][c].special === SPECIALS.STRIPE_V) cell.textContent = '‚îÉ';
            else if (board[r][c].special === SPECIALS.BOMB) cell.textContent = 'üí£';
            else if (board[r][c].special === SPECIALS.RAINBOW) {
              cell.style.background = 'linear-gradient(135deg, #e74c3c, #f1c40f, #2ecc71, #3498db, #9b59b6)';
              cell.textContent = 'üåà';
            }
          }
          if (selected && selected.r === r && selected.c === c) {
            cell.classList.add('selected');
          }
          cell.onclick = () => handleClick(r, c);
          container.appendChild(cell);
        }
      }
    }

    function updateUI() {
      document.getElementById('level').textContent = level + 1;
      document.getElementById('score').textContent = score;
      document.getElementById('target').textContent = LEVELS[level].target;
      const movesEl = document.getElementById('moves');
      movesEl.textContent = moves;
      movesEl.classList.toggle('warning', moves <= 5);
    }

    function handleClick(r, c) {
      if (animating || !board[r][c]) return;
      
      if (!selected) {
        selected = { r, c };
        render();
        return;
      }

      if (selected.r === r && selected.c === c) {
        selected = null;
        render();
        return;
      }

      const dr = Math.abs(selected.r - r);
      const dc = Math.abs(selected.c - c);
      
      if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
        trySwap(selected.r, selected.c, r, c);
      } else {
        selected = { r, c };
        render();
      }
    }

    async function trySwap(r1, c1, r2, c2) {
      animating = true;
      selected = null;
      
      swap(r1, c1, r2, c2);
      render();
      await delay(150);
      
      const matches = findMatches();
      if (matches.length === 0) {
        swap(r1, c1, r2, c2);
        render();
        animating = false;
        return;
      }
      
      moves--;
      combo = 0;
      await processMatches();
      animating = false;
      updateUI();
      checkGameEnd();
    }

    function swap(r1, c1, r2, c2) {
      const temp = board[r1][c1];
      board[r1][c1] = board[r2][c2];
      board[r2][c2] = temp;
    }

    function findMatches() {
      const matches = [];
      
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE - 2; c++) {
          if (board[r][c] && board[r][c+1] && board[r][c+2] &&
              board[r][c].color === board[r][c+1].color &&
              board[r][c].color === board[r][c+2].color) {
            let len = 3;
            while (c + len < SIZE && board[r][c+len]?.color === board[r][c].color) len++;
            matches.push({ r, c, len, horizontal: true });
            c += len - 1;
          }
        }
      }
      
      for (let c = 0; c < SIZE; c++) {
        for (let r = 0; r < SIZE - 2; r++) {
          if (board[r][c] && board[r+1][c] && board[r+2][c] &&
              board[r][c].color === board[r+1][c].color &&
              board[r][c].color === board[r+2][c].color) {
            let len = 3;
            while (r + len < SIZE && board[r+len]?.[c]?.color === board[r][c].color) len++;
            matches.push({ r, c, len, horizontal: false });
            r += len - 1;
          }
        }
      }
      
      return matches;
    }

    async function processMatches() {
      let matches = findMatches();
      
      while (matches.length > 0) {
        combo++;
        showCombo();
        
        const toRemove = new Set();
        for (const m of matches) {
          for (let i = 0; i < m.len; i++) {
            const r = m.horizontal ? m.r : m.r + i;
            const c = m.horizontal ? m.c + i : m.c;
            toRemove.add(`${r},${c}`);
          }
          
          if (m.len >= 4) {
            const midIdx = Math.floor(m.len / 2);
            const mr = m.horizontal ? m.r : m.r + midIdx;
            const mc = m.horizontal ? m.c + midIdx : m.c;
            if (m.len >= 5) {
              board[mr][mc] = { color: board[mr][mc].color, special: SPECIALS.RAINBOW };
            } else {
              board[mr][mc] = { 
                color: board[mr][mc].color, 
                special: m.horizontal ? SPECIALS.STRIPE_V : SPECIALS.STRIPE_H 
              };
            }
            toRemove.delete(`${mr},${mc}`);
          }
        }
        
        const affected = [];
        for (const key of toRemove) {
          const [r, c] = key.split(',').map(Number);
          if (board[r][c]?.special === SPECIALS.STRIPE_H) {
            for (let i = 0; i < SIZE; i++) affected.push({ r, c: i });
          } else if (board[r][c]?.special === SPECIALS.STRIPE_V) {
            for (let i = 0; i < SIZE; i++) affected.push({ r: i, c });
          } else if (board[r][c]?.special === SPECIALS.BOMB) {
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (r+dr >= 0 && r+dr < SIZE && c+dc >= 0 && c+dc < SIZE) {
                  affected.push({ r: r+dr, c: c+dc });
                }
              }
            }
          }
        }
        for (const a of affected) toRemove.add(`${a.r},${a.c}`);
        
        score += toRemove.size * 10 * (1 + combo * 0.5);
        
        for (const key of toRemove) {
          const [r, c] = key.split(',').map(Number);
          board[r][c] = null;
        }
        
        render();
        await delay(200);
        
        applyGravity();
        render();
        await delay(300);
        
        matches = findMatches();
        updateUI();
      }
      
      hideCombo();
    }

    function applyGravity() {
      const numColors = LEVELS[level].colors;
      for (let c = 0; c < SIZE; c++) {
        let writeRow = SIZE - 1;
        for (let r = SIZE - 1; r >= 0; r--) {
          if (board[r][c]) {
            if (r !== writeRow) {
              board[writeRow][c] = board[r][c];
              board[r][c] = null;
            }
            writeRow--;
          }
        }
        for (let r = writeRow; r >= 0; r--) {
          board[r][c] = { color: Math.floor(Math.random() * numColors), special: SPECIALS.NONE };
        }
      }
    }

    function showCombo() {
      const el = document.getElementById('combo');
      el.textContent = `${combo}x ËøûÂáª!`;
      el.classList.add('show');
    }

    function hideCombo() {
      document.getElementById('combo').classList.remove('show');
    }

    function checkGameEnd() {
      const config = LEVELS[level];
      if (score >= config.target) {
        showModal(true);
      } else if (moves <= 0) {
        showModal(false);
      }
    }

    function showModal(win) {
      const modal = document.getElementById('modal');
      document.getElementById('modal-title').textContent = win ? 'ÊÅ≠ÂñúÈÄöÂÖ≥!' : 'Ê∏∏ÊàèÁªìÊùü';
      document.getElementById('final-score').textContent = score;
      
      const stars = document.querySelectorAll('#stars .star');
      const thresholds = [LEVELS[level].target, LEVELS[level].target * 1.5, LEVELS[level].target * 2.5];
      stars.forEach((s, i) => s.classList.toggle('active', score >= thresholds[i]));
      
      modal.classList.add('show');
    }

    function restartGame() {
      init();
    }

    function nextLevel() {
      if (level < LEVELS.length - 1) level++;
      init();
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    init();
  </script>
</body>
</html>
