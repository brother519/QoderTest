# 用户认证系统技术方案

## 一、系统概述

本方案基于 Node.js + Express + JWT 技术栈,采用混合认证方式,提供完整的用户认证和授权解决方案。

## 二、技术架构设计

### 2.1 技术栈选型

- **后端框架**: Node.js + Express
- **数据库**: MongoDB/PostgreSQL
- **认证方式**: JWT + Session 混合模式
- **密码加密**: bcrypt
- **双因素认证**: speakeasy (TOTP)
- **邮件服务**: nodemailer
- **缓存**: Redis (存储 token 黑名单、验证码等)

### 2.2 系统架构图

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │ HTTPS
       ▼
┌─────────────────────────────────────┐
│       API Gateway/Load Balancer     │
└──────┬──────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│      Authentication Middleware      │
│  (JWT Verification + Session Check) │
└──────┬──────────────────────────────┘
       │
       ▼
┌──────────────────────────┬──────────────────┐
│   Auth Service           │  User Service    │
│  - 登录/注册             │  - 用户信息管理  │
│  - Token 管理            │  - 角色管理      │
│  - 密码重置              │  - 权限管理      │
│  - 2FA 验证              │                  │
└──────┬───────────────────┴──────────────────┘
       │
       ▼
┌──────────────────────────┬──────────────────┐
│   Database               │  Redis Cache     │
│  - 用户表                │  - Token 黑名单  │
│  - 角色表                │  - 验证码        │
│  - 权限表                │  - Session       │
└──────────────────────────┴──────────────────┘
```

### 2.3 数据库设计

#### 用户表 (users)
```javascript
{
  _id: ObjectId,
  username: String (unique),
  email: String (unique),
  password: String (hashed),
  phoneNumber: String,
  isEmailVerified: Boolean,
  isPhoneVerified: Boolean,
  twoFactorEnabled: Boolean,
  twoFactorSecret: String,
  roleId: ObjectId,
  status: String, // active, inactive, locked
  lastLoginAt: Date,
  createdAt: Date,
  updatedAt: Date
}
```

#### 角色表 (roles)
```javascript
{
  _id: ObjectId,
  name: String, // admin, user, moderator
  permissions: [String],
  description: String,
  createdAt: Date
}
```

#### Token 黑名单表 (token_blacklist)
```javascript
{
  token: String,
  expiresAt: Date
}
```

#### 密码重置表 (password_resets)
```javascript
{
  userId: ObjectId,
  token: String,
  expiresAt: Date,
  used: Boolean
}
```

## 三、核心功能实现步骤

### 3.1 用户注册流程

**步骤 1**: 创建项目结构
```bash
npm init -y
npm install express mongoose bcrypt jsonwebtoken express-validator dotenv
npm install --save-dev nodemon
```

**步骤 2**: 实现用户注册接口
```javascript
// routes/auth.js
router.post('/register', [
  // 数据验证
  body('username').isLength({ min: 3 }),
  body('email').isEmail(),
  body('password').isLength({ min: 8 })
], async (req, res) => {
  // 1. 验证输入
  // 2. 检查用户是否已存在
  // 3. 密码加密 (bcrypt.hash)
  // 4. 创建用户记录
  // 5. 发送验证邮件
  // 6. 返回成功响应
});
```

**步骤 3**: 邮箱验证
```javascript
router.get('/verify-email/:token', async (req, res) => {
  // 1. 验证 token
  // 2. 更新用户 isEmailVerified 状态
  // 3. 返回验证结果
});
```

### 3.2 用户登录流程

**步骤 1**: 基础登录实现
```javascript
router.post('/login', async (req, res) => {
  // 1. 验证用户名/邮箱存在
  // 2. 验证密码 (bcrypt.compare)
  // 3. 检查账户状态
  // 4. 生成 JWT token
  // 5. 创建 Session (可选)
  // 6. 返回 token 和用户信息
});
```

**步骤 2**: JWT Token 生成
```javascript
const generateToken = (userId, role) => {
  return jwt.sign(
    { userId, role },
    process.env.JWT_SECRET,
    { expiresIn: '1h' }
  );
};

const generateRefreshToken = (userId) => {
  return jwt.sign(
    { userId, type: 'refresh' },
    process.env.JWT_REFRESH_SECRET,
    { expiresIn: '7d' }
  );
};
```

**步骤 3**: Token 刷新机制
```javascript
router.post('/refresh-token', async (req, res) => {
  // 1. 验证 refresh token
  // 2. 检查 token 是否在黑名单
  // 3. 生成新的 access token
  // 4. 返回新 token
});
```

### 3.3 双因素认证 (2FA)

**步骤 1**: 启用 2FA
```javascript
npm install speakeasy qrcode

router.post('/enable-2fa', authenticateToken, async (req, res) => {
  // 1. 生成密钥
  const secret = speakeasy.generateSecret({
    name: `YourApp (${user.email})`
  });
  
  // 2. 生成二维码
  // 3. 保存密钥到用户记录
  // 4. 返回二维码供用户扫描
});
```

**步骤 2**: 验证 2FA
```javascript
router.post('/verify-2fa', authenticateToken, async (req, res) => {
  // 1. 验证用户输入的 6 位码
  const verified = speakeasy.totp.verify({
    secret: user.twoFactorSecret,
    encoding: 'base32',
    token: req.body.token
  });
  
  // 2. 更新用户 2FA 状态
  // 3. 返回验证结果
});
```

**步骤 3**: 登录时 2FA 验证
```javascript
router.post('/login/2fa-verify', async (req, res) => {
  // 1. 验证临时 token (登录后未完成 2FA)
  // 2. 验证 2FA 码
  // 3. 生成正式 JWT token
  // 4. 返回完整认证信息
});
```

### 3.4 密码重置流程

**步骤 1**: 请求密码重置
```javascript
router.post('/forgot-password', async (req, res) => {
  // 1. 验证邮箱存在
  // 2. 生成重置 token
  // 3. 保存到 password_resets 表
  // 4. 发送重置邮件
  // 5. Token 有效期 1 小时
});
```

**步骤 2**: 重置密码
```javascript
router.post('/reset-password', async (req, res) => {
  // 1. 验证 token 有效性
  // 2. 检查 token 是否已使用
  // 3. 验证新密码强度
  // 4. 更新用户密码
  // 5. 标记 token 为已使用
  // 6. 发送确认邮件
});
```

### 3.5 角色权限管理 (RBAC)

**步骤 1**: 定义权限常量
```javascript
const PERMISSIONS = {
  USER_READ: 'user:read',
  USER_WRITE: 'user:write',
  USER_DELETE: 'user:delete',
  ADMIN_ACCESS: 'admin:access'
};
```

**步骤 2**: 权限检查中间件
```javascript
const checkPermission = (requiredPermission) => {
  return async (req, res, next) => {
    // 1. 从 token 获取用户角色
    // 2. 查询角色权限
    // 3. 验证是否有所需权限
    // 4. 允许或拒绝访问
  };
};

// 使用示例
router.delete('/users/:id', 
  authenticateToken, 
  checkPermission(PERMISSIONS.USER_DELETE), 
  deleteUser
);
```

**步骤 3**: 角色管理接口
```javascript
// 创建角色
router.post('/roles', checkPermission(PERMISSIONS.ADMIN_ACCESS), createRole);

// 分配角色
router.put('/users/:id/role', checkPermission(PERMISSIONS.ADMIN_ACCESS), assignRole);
```

### 3.6 认证中间件

**步骤 1**: JWT 验证中间件
```javascript
const authenticateToken = async (req, res, next) => {
  const token = req.headers['authorization']?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  try {
    // 1. 验证 token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // 2. 检查黑名单
    const isBlacklisted = await checkTokenBlacklist(token);
    if (isBlacklisted) {
      return res.status(401).json({ error: 'Token revoked' });
    }
    
    // 3. 加载用户信息
    req.user = await User.findById(decoded.userId);
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid token' });
  }
};
```

**步骤 2**: Session 验证中间件 (混合模式)
```javascript
const express = require('express');
const session = require('express-session');
const RedisStore = require('connect-redis').default;
const redis = require('redis');

const redisClient = redis.createClient();

app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: true, // HTTPS only
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}));
```

### 3.7 用户登出

```javascript
router.post('/logout', authenticateToken, async (req, res) => {
  // 1. 将 token 加入黑名单
  await addToBlacklist(req.token, decoded.exp);
  
  // 2. 销毁 session
  req.session.destroy();
  
  // 3. 清除 Redis 缓存
  await redisClient.del(`user:${req.user._id}`);
  
  res.json({ message: 'Logged out successfully' });
});
```

## 四、安全性措施

### 4.1 密码安全
- 使用 bcrypt 进行密码哈希 (salt rounds: 10-12)
- 密码强度要求: 至少 8 位,包含大小写字母、数字、特殊字符
- 密码历史记录: 防止重复使用最近 5 个密码

### 4.2 Token 安全
- JWT 签名使用强密钥 (至少 256 位)
- Access Token 短期有效 (1 小时)
- Refresh Token 长期有效 (7 天)
- Token 轮换机制
- Token 黑名单管理

### 4.3 通信安全
- 强制使用 HTTPS
- 设置安全头 (helmet.js)
- CORS 配置
- Rate Limiting (防暴力破解)

### 4.4 数据安全
- 敏感信息加密存储
- SQL 注入防护 (使用 ORM)
- XSS 防护
- CSRF 防护

### 4.5 监控与日志
```javascript
// 登录尝试记录
const logLoginAttempt = async (username, success, ip) => {
  await LoginLog.create({
    username,
    success,
    ipAddress: ip,
    timestamp: new Date()
  });
  
  // 检测异常登录
  if (!success) {
    await checkBruteForce(username, ip);
  }
};
```

## 五、实施计划

### 第一阶段:基础认证 (1-2 周)
1. 搭建项目基础架构
2. 实现用户注册/登录/登出
3. JWT Token 生成与验证
4. 密码加密与验证
5. 基础单元测试

### 第二阶段:高级功能 (1-2 周)
1. 邮箱验证功能
2. 密码重置/找回
3. Token 刷新机制
4. Session 混合模式
5. Redis 集成

### 第三阶段:安全增强 (1 周)
1. 双因素认证 (2FA)
2. 角色权限管理 (RBAC)
3. Rate Limiting
4. 安全头配置
5. 日志监控系统

### 第四阶段:测试与优化 (1 周)
1. 完整功能测试
2. 安全测试 (OWASP)
3. 性能优化
4. 文档编写
5. 部署上线

## 六、关键代码示例

### 6.1 完整登录流程
```javascript
const login = async (req, res) => {
  try {
    const { username, password, twoFactorCode } = req.body;
    
    // 1. 查找用户
    const user = await User.findOne({ 
      $or: [{ username }, { email: username }] 
    }).populate('roleId');
    
    if (!user) {
      await logLoginAttempt(username, false, req.ip);
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // 2. 检查账户状态
    if (user.status === 'locked') {
      return res.status(403).json({ error: 'Account locked' });
    }
    
    // 3. 验证密码
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      await logLoginAttempt(username, false, req.ip);
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // 4. 2FA 验证
    if (user.twoFactorEnabled) {
      if (!twoFactorCode) {
        // 返回临时 token,要求 2FA
        const tempToken = generateTempToken(user._id);
        return res.json({ 
          requiresTwoFactor: true, 
          tempToken 
        });
      }
      
      const isValid2FA = speakeasy.totp.verify({
        secret: user.twoFactorSecret,
        encoding: 'base32',
        token: twoFactorCode,
        window: 2
      });
      
      if (!isValid2FA) {
        return res.status(401).json({ error: 'Invalid 2FA code' });
      }
    }
    
    // 5. 生成 tokens
    const accessToken = generateToken(user._id, user.roleId.name);
    const refreshToken = generateRefreshToken(user._id);
    
    // 6. 创建 session
    req.session.userId = user._id;
    req.session.role = user.roleId.name;
    
    // 7. 缓存用户信息
    await redisClient.setEx(
      `user:${user._id}`, 
      3600, 
      JSON.stringify(user)
    );
    
    // 8. 更新最后登录时间
    user.lastLoginAt = new Date();
    await user.save();
    
    // 9. 记录成功登录
    await logLoginAttempt(username, true, req.ip);
    
    res.json({
      accessToken,
      refreshToken,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.roleId.name,
        permissions: user.roleId.permissions
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
```

### 6.2 环境配置示例
```env
# .env
NODE_ENV=production
PORT=3000

# Database
MONGODB_URI=mongodb://localhost:27017/auth_db
REDIS_URL=redis://localhost:6379

# JWT
JWT_SECRET=your-super-secret-jwt-key-min-256-bits
JWT_REFRESH_SECRET=your-refresh-token-secret
JWT_EXPIRES_IN=1h
JWT_REFRESH_EXPIRES_IN=7d

# Session
SESSION_SECRET=your-session-secret

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# Security
BCRYPT_ROUNDS=12
MAX_LOGIN_ATTEMPTS=5
LOCK_TIME=30
```

## 七、测试策略

### 7.1 单元测试
```javascript
describe('Authentication', () => {
  test('should register new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser',
        email: 'test@example.com',
        password: 'Test@1234'
      });
    expect(response.status).toBe(201);
  });
  
  test('should login with valid credentials', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        username: 'testuser',
        password: 'Test@1234'
      });
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('accessToken');
  });
});
```

### 7.2 集成测试
- 完整的注册到登录流程
- 密码重置流程
- 2FA 启用和验证流程
- Token 刷新流程

### 7.3 安全测试
- SQL 注入测试
- XSS 攻击测试
- CSRF 攻击测试
- 暴力破解测试
- Token 伪造测试

## 八、部署建议

### 8.1 生产环境配置
- 使用 PM2 进行进程管理
- Nginx 反向代理
- SSL/TLS 证书配置
- 数据库主从复制
- Redis 集群

### 8.2 监控与维护
- 应用性能监控 (APM)
- 日志聚合 (ELK Stack)
- 错误追踪 (Sentry)
- 健康检查端点
- 备份策略

## 九、后续优化方向

1. **单点登录 (SSO)**: 支持多应用统一认证
2. **社交登录**: 集成 Google, GitHub, Facebook 等
3. **生物识别**: 指纹、人脸识别支持
4. **智能风控**: 基于行为分析的异常检测
5. **微服务拆分**: 将认证服务独立部署

---

本方案提供了完整的用户认证系统设计和实现路径,可根据实际业务需求进行调整和扩展。
